using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;

namespace Merq.DependencyInjection;

[Generator(LanguageNames.CSharp)]
public class RegistrationsGenerator : IIncrementalGenerator
{
    static readonly SymbolDisplayFormat fullNameFormat = new SymbolDisplayFormat(
        typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
        genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
        miscellaneousOptions: SymbolDisplayMiscellaneousOptions.ExpandNullable);


    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var types = context.CompilationProvider.SelectMany((x, c) =>
        {
            var asm = x.Assembly;
            var visitor = new TypesVisitor(s => x.IsSymbolAccessibleWithin(s, asm), c);
            asm.Accept(visitor);
            return visitor.TypeSymbols;
        });

        var services = types.Where(x => x.GetAttributes().Any(a => a.AttributeClass?.Name == "ServiceAttribute"))
            .Select((x, _) => new
            {
                Type = x,
                Lifetime = (int)x.GetAttributes().First(a => a.AttributeClass?.Name == "ServiceAttribute").ConstructorArguments[0].Value!
            });

        var scoped = services.Where(x => x.Lifetime == 0).Select((x, _) => x.Type);
        var singleton = services.Where(x => x.Lifetime == 1).Select((x, _) => x.Type);
        var transient = services.Where(x => x.Lifetime == 2).Select((x, _) => x.Type);

        context.RegisterSourceOutput(scoped.Collect(), (ctx, data) => AddPartial("AddScoped", ctx, data));
        context.RegisterSourceOutput(singleton.Collect(), (ctx, data) => AddPartial("AddSingleton", ctx, data));
        context.RegisterSourceOutput(transient.Collect(), (ctx, data) => AddPartial("AddTransient", ctx, data));
    }

    void AddPartial(string methodName, SourceProductionContext ctx, ImmutableArray<INamedTypeSymbol> data)
    {
        var builder = new StringBuilder();
        builder.AppendLine(
        $$"""
            // <auto-generated />
            using Microsoft.Extensions.DependencyInjection;
            
            namespace Merq
            {
                static partial class MerqServicesExtension
                {
                    static partial void {{methodName}}Services(IServiceCollection services)
                    {
            """);

        AddServices(data, methodName, builder);
        builder.AppendLine(
        """
                    }
                }
            }
            """);

        ctx.AddSource(methodName + ".g", builder.ToString());
    }

    void AddServices(ImmutableArray<INamedTypeSymbol> types, string methodName, StringBuilder output)
    {
        foreach (var type in types)
        {
            var impl = type.ToDisplayString(fullNameFormat);
            output.AppendLine($"        services.{methodName}<{impl}>();");
            foreach (var iface in type.AllInterfaces)
            {
                output.AppendLine($"        services.{methodName}<{iface.ToDisplayString(fullNameFormat)}>(s => s.GetRequiredService<{impl}>());");
            }
        }
    }

    class TypesVisitor : SymbolVisitor
    {
        Func<ISymbol, bool> isAccessible;
        CancellationToken cancellation;
        HashSet<INamedTypeSymbol> types = new(SymbolEqualityComparer.Default);

        public TypesVisitor(Func<ISymbol, bool> isAccessible, CancellationToken cancellation)
        {
            this.isAccessible = isAccessible;
            this.cancellation = cancellation;
        }

        public HashSet<INamedTypeSymbol> TypeSymbols => types;

        public override void VisitAssembly(IAssemblySymbol symbol)
        {
            cancellation.ThrowIfCancellationRequested();
            symbol.GlobalNamespace.Accept(this);
        }

        public override void VisitNamespace(INamespaceSymbol symbol)
        {
            foreach (var namespaceOrType in symbol.GetMembers())
            {
                cancellation.ThrowIfCancellationRequested();
                namespaceOrType.Accept(this);
            }
        }

        public override void VisitNamedType(INamedTypeSymbol type)
        {
            cancellation.ThrowIfCancellationRequested();

            if (!isAccessible(type) || !types.Add(type))
                return;

            var nestedTypes = type.GetTypeMembers();
            if (nestedTypes.IsDefaultOrEmpty)
                return;

            foreach (var nestedType in nestedTypes)
            {
                cancellation.ThrowIfCancellationRequested();
                nestedType.Accept(this);
            }
        }
    }
}
