using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Merq;

[Generator(LanguageNames.CSharp)]
public class RecordFactoryGenerator : IIncrementalGenerator
{
    static readonly SymbolDisplayFormat fullNameFormat = new SymbolDisplayFormat(
        typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
        genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
        miscellaneousOptions: SymbolDisplayMiscellaneousOptions.ExpandNullable);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var types = context.CompilationProvider.SelectMany((x, c) =>
            TypesVisitor.Visit(x.GlobalNamespace, symbol => x.IsSymbolAccessibleWithin(symbol, x.Assembly) && symbol.IsRecord, c));

        context.RegisterSourceOutput(types, (ctx, data) =>
        {
            var ctor = data.InstanceConstructors
                .Where(x => x.DeclaredAccessibility == Accessibility.Public || x.DeclaredAccessibility == Accessibility.Internal)
                .OrderByDescending(x => x.Parameters.Length).FirstOrDefault();
            if (ctor == null)
                return;

            var builder = new StringBuilder();

            builder.Append(
                $$"""
                // <auto-generated />
                namespace {{data.ContainingNamespace.ToDisplayString(fullNameFormat)}}
                {
                    static partial class __{{data.Name}}Factory
                    {
                        public static {{data.Name}} Create(dynamic value)
                            => new {{data.Name}}(
                """)
                .Append(string.Join(", ", ctor.Parameters.Select(x => $"value.{x.Name}")))
                .Append(")");

            // Get properties that can be set and are not named (case insensitive) as ctor parameters
            var properties = data.GetMembers().OfType<IPropertySymbol>()
                .Where(x => x.SetMethod != null && !ctor.Parameters.Any(y => string.Equals(y.Name, x.Name, StringComparison.OrdinalIgnoreCase)))
                .ToImmutableArray();

            if (!properties.IsDefaultOrEmpty)
            {
                builder.AppendLine(
                    $$"""

                                {
                    """);

                foreach (var prop in properties)
                {
                    builder.AppendLine(
                        $"""
                                        {prop.Name} = value.{prop.Name},
                        """);
                }

                builder.AppendLine(
                    $$"""
                                };
                    """);
            }
            else
            {
                builder.AppendLine(";");
            }

            builder.AppendLine(
                """
                    }
                }
                """);

            ctx.AddSource(data.Name + ".Factory.g", builder.ToString().Replace("\r\n", "\n").Replace("\n", Environment.NewLine));
        });

        context.RegisterSourceOutput(
            // Only generate a partial implicit cast operator for partial records
            // NOTE: if there are no declaring syntax references, it's because the type is declared 
            // in another project
            types.Where(x => x.DeclaringSyntaxReferences.Any() && x.DeclaringSyntaxReferences.All(
                r => r.GetSyntax() is RecordDeclarationSyntax c && c.Modifiers.Any(
                    m => m.IsKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind.PartialKeyword))) &&
                // Don't generate duplicate method names. We also don't generate if there's already a Create with 
                // a single parameter.
                !x.GetMembers().OfType<IMethodSymbol>().Where(
                    x => x.Name == "Create" && x.IsStatic && x.Parameters.Length == 1 &&
                         (x.Parameters[0].Type.SpecialType == SpecialType.System_Object ||
                          x.Parameters[0].Type.TypeKind == TypeKind.Dynamic)).Any()),
            (ctx, data) =>
            {
                ctx.AddSource(data.Name + ".Create.g",
                    $$"""
                    // <auto-generated />
                    namespace {{data.ContainingNamespace.ToDisplayString(fullNameFormat)}}
                    {
                        partial record {{data.Name}}
                        {
                            public static {{data.Name}} Create(dynamic value)
                                => __{{data.Name}}Factory.Create(value);
                        }
                    }
                    """.Replace("\r\n", "\n").Replace("\n", Environment.NewLine));
            });
    }

    class TypesVisitor : SymbolVisitor
    {
        readonly Func<INamedTypeSymbol, bool> shouldInclude;
        readonly CancellationToken cancellation;
        readonly HashSet<INamedTypeSymbol> types = new(SymbolEqualityComparer.Default);

        public TypesVisitor(Func<INamedTypeSymbol, bool> shouldInclude, CancellationToken cancellation)
        {
            this.shouldInclude = shouldInclude;
            this.cancellation = cancellation;
        }

        public HashSet<INamedTypeSymbol> TypeSymbols => types;

        public static IEnumerable<INamedTypeSymbol> Visit(INamespaceSymbol symbol, Func<INamedTypeSymbol, bool> shouldInclude, CancellationToken cancellation)
        {
            var visitor = new TypesVisitor(shouldInclude, cancellation);
            symbol.Accept(visitor);
            return visitor.TypeSymbols;
        }

        public override void VisitAssembly(IAssemblySymbol symbol)
        {
            cancellation.ThrowIfCancellationRequested();
            symbol.GlobalNamespace.Accept(this);
        }

        public override void VisitNamespace(INamespaceSymbol symbol)
        {
            foreach (var namespaceOrType in symbol.GetMembers())
            {
                cancellation.ThrowIfCancellationRequested();
                namespaceOrType.Accept(this);
            }
        }

        public override void VisitNamedType(INamedTypeSymbol type)
        {
            cancellation.ThrowIfCancellationRequested();

            if (!shouldInclude(type) || !types.Add(type))
                return;

            var nestedTypes = type.GetTypeMembers();
            if (nestedTypes.IsDefaultOrEmpty)
                return;

            foreach (var nestedType in nestedTypes)
            {
                cancellation.ThrowIfCancellationRequested();
                nestedType.Accept(this);
            }
        }
    }

}
